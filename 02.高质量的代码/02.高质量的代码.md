# 目录

### [面试题1：数值的整数次方](https://github.com/Duanyu950425/-offer/blob/master/02.%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81/02.%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81.md#%E9%9D%A2%E8%AF%95%E9%A2%981%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9-1)

### [面试题2：打印从1到最大的n位数](https://github.com/Duanyu950425/-offer/blob/master/02.%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81/02.%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81.md#%E9%9D%A2%E8%AF%95%E9%A2%982%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0-1)

### [面试题3：删除链表的节点](https://github.com/Duanyu950425/-offer/blob/master/02.%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81/02.%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81.md#%E9%9D%A2%E8%AF%95%E9%A2%983%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9-1)

### [面试题4：正则表达式匹配](https://github.com/Duanyu950425/-offer/blob/master/02.%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81/02.%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81.md#%E9%9D%A2%E8%AF%95%E9%A2%984%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D-1)

### [面试题5：表示数值的字符串](https://github.com/Duanyu950425/-offer/blob/master/02.%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81/02.%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81.md#%E9%9D%A2%E8%AF%95%E9%A2%985%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2-1)

### [面试题6：调整数组顺序使奇数位于偶数前面](https://github.com/Duanyu950425/-offer/blob/master/02.%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81/02.%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81.md#%E9%9D%A2%E8%AF%95%E9%A2%986%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2-1)

### [面试题7：链表中倒数第k个节点](https://github.com/Duanyu950425/-offer/blob/master/02.%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81/02.%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81.md#%E9%9D%A2%E8%AF%95%E9%A2%987%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9-1)

### [面试题8：链表中环的入口地址](https://github.com/Duanyu950425/-offer/blob/master/02.%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81/02.%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81.md#%E9%9D%A2%E8%AF%95%E9%A2%988%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E5%9C%B0%E5%9D%80-1)

### [面试题9：反转链表](https://github.com/Duanyu950425/-offer/blob/master/02.%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81/02.%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81.md#%E9%9D%A2%E8%AF%95%E9%A2%989%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-1)

### [面试题10：合并两个排序的链表](https://github.com/Duanyu950425/-offer/blob/master/02.%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81/02.%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81.md#%E9%9D%A2%E8%AF%95%E9%A2%9810%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8-1)

### [面试题11：树的子结构](https://github.com/Duanyu950425/-offer/blob/master/02.%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81/02.%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81.md#%E9%9D%A2%E8%AF%95%E9%A2%9811%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84)







# 高质量的代码

## 面试题1：[数值的整数次方](https://github.com/Duanyu950425/-offer/blob/master/02.%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81/02.%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81_%E4%BB%A3%E7%A0%81/01.%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9.cpp)

**题目**：实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。

**解题思路**：考虑问题要全面。1. 底数为0，指数为负？2. 指数为负？3. 正数情况

```c++
double Power(double base, int exponent)
{
    if (equal(base, 0.0) && exponent < 0)
        return 0.0;
    unsigned int absExponent = (unsigned int)(exponent);
    if (exponent < 0)
        absExponent = (unsigned int)(-exponent);
    double result = PowerWithUnsignedExponent(base, absExponent);
    if (exponent < 0)
        result = 1.0 / result;
    return result;
}
double PowerWithUnsignedExponent(double base, int exponent)
{
    double result = 1.0;
    for (int i = 1; i <= exponent; ++i)
        result *= base;
    return result;
}
bool equal(double base, double val)
{
    double diff = base - val;
    if (diff >= -0.0000001 && diff < 0.0000001)
        return true;
    return false;
}
```

## 面试题2：[打印从1到最大的n位数](https://github.com/Duanyu950425/-offer/blob/master/02.%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81/02.%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81_%E4%BB%A3%E7%A0%81/02.%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0.cpp)

**题目**：输入数字n， 按顺序打印出从1到最大的n位十进制数。比如输入3，则打印出1、2、3一直到最大的3位数999。

**解题思路**：这道题很有可能会陷入大数溢出的困扰。为了解决这一困扰，我们采用字符串或者数组来表示大数。因为数字最大是n位，因此我们需要一个长度为n+1的字符串（最后有结束符'\0'）。首先把字符串中的每一个数字都初始化为'0'，然后每一次为字符串表示的数字加1，再打印出来。

## 面试题3：[删除链表的节点](https://github.com/Duanyu950425/-offer/blob/master/02.%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81/02.%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81_%E4%BB%A3%E7%A0%81/03.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9.cpp)

**题目一**：在O(1)的时间内删除链表节点

​	给定单向链表的头结点和一个节点指针，定义一个函数在O(1)时间内删除该节点。

**解题思路**：删除的节点可能是三种情况：1. 链表中有多个节点，删除的是尾节点；2. 链表中只有一个节点，删除的即使头结点也是尾节点；3. 链表中有多个节点，删除的不是尾节点。

```c++
struct ListNode
{
	int m_nValue;
	ListNode *m_pNext;
};
void DeleteNode(ListNode **pListHead, ListNode *pToBeDeleted)
{
    if (pListHead == NULL || pToBeDeleted == NULL)
        return ;
    if (pToBeDeleted->m_pNext != NULL)
    {
        ListNode *pNext = pToBeDeleted->m_pNext;
        pToBeDeleted->m_nValue = pNext->m_nValue;
        pToBeDeleted->m_pNext = pNext->m_pNext;
        
        delete pToBeDeleted;
        pToBeDeleted = NULL;
    }
    else if (*pListHead == pToBeDeleted)
    {
        delete pToBeDeleted;
        pToBeDeleted = NULL;
        *pListHead = NULL;
    }
    else
    {
        ListNode *pNode = pListHead;
        while (pNode->m_pNext != pToBeDeleted)
           pNode = pNode->m_pNext;
        pNode->m_pNext = NULL;
        delete pToBeDeleted;
        pToBeDeleted = NULL;
    }
}
```

**题目二**：在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1->2->3->3->4->4->5 处理后为 1->2->5

**解题思路**：要将重复的节点全部删除。

```c++
ListNode* deleteDuplication(ListNode* pHead)
{
    if (pHead == NULL)
        return NULL;
	ListNode *pPre = NULL;
    ListNode *pCurrent = pHead;
    while (pCurrent != NULL)
    {
        ListNode *pNext = pCurrent->next;
        bool needDel = false;
        if (pNext != NULL && pCurrent->val == pNext->val)
            needDel = true;
        if (!needDel)
        {
            pPre = pCurrent->next;
        	pCurrent = pCurrent->next;
        }
        else
        {
            int value = pCurrent->val;
            ListNode *pToBeDel = pCurrent;
            while (pToBeDel != NULL && pToBeDel->val == value)
            {
                pNext = pToBeDel->next;
                delete pToBeDel;
                pToBeDel = NULL;
                pToBeDel = pNext;
            }
            if (pPre == NULL)
                pHead = pNext;
            else
                pPre->next = pNext;
            pCurrent = pNext;
        }
    }
    return pHead;
}
```



## 面试题4：[正则表达式匹配](https://github.com/Duanyu950425/-offer/blob/master/02.%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81/02.%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81_%E4%BB%A3%E7%A0%81/04.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D.cpp)

**题目**：请实现一个函数用来匹配包括'.'和'\*'的正则表达式。模式中的字符'.'表示任意一个字符，而'\*'表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab\*ac\*a"匹配，但是与"aa.a"和"ab\*a"均不匹配

**解题思路**：解这题需要把题意仔细研究清楚。
    

​	首先，考虑特殊情况：
​         

1. 两个字符串都为**空**，返回true。

2. 当**第一个字符串不空**，而**第二个字符串空了**，返回false（因为这样，就无法匹配成功了，而如果第一个字符串空了，第二个字符串非空，还是可能匹配成功的，比如第二个字符串是“a\*a\*a\*a\*”，由于‘\*’之前的元素可以出现0次，所以有可能匹配成功）
       

3. 之后就开始匹配第一个字符，这里有两种可能：匹配成功或匹配失败。但考虑到pattern下一个字符可能是‘\*’， 这里我们分两种情况讨论：pattern下一个字符为‘\*’或不为‘\*’：
             

   ​			1> **pattern下一个字符不为‘\*’**：这种情况比较简单，直接匹配当前字符。如果匹配成功，继续匹配下一个；如果匹配失败，直接返回false。注意这里的 “匹配成功”，除了两个字符相同的情况外，还有一种情况，就是pattern的当前字符为‘.’，同时str的当前字符不为‘\0’。
   ​          

   ​			2> **pattern下一个字符为‘\*’**时，稍微复杂一些，因为‘\*’可以代表0个或多个。

- 这里把这些情况都考虑到：

​					a> **当‘\*’匹配0个字符时**，str当前字符不变，pattern当前字符后移两位，跳过这个‘\*’符号；
​               

​					b> **当‘\*’匹配1个或多个时**，str当前字符移向下一个，pattern当前字符不变。（这里匹配1个或多个可以看成一种情况，因为：当匹配一个时，由于str移到了下一个字符，而pattern字符不变，就回到了上边的情况a；当匹配多于一个字符时，相当于从str的下一个字符继续开始匹配）之后再写代码就很简单了。

```c++
bool match(char* str, char* pattern)
{
    if (*str == '\0' && *pattern == '\0')
        return true;
    if (*str != '\0' && *pattern == '\0')
        return false;
    if (*(pattern + 1) != '*')
    {
        if (*str == *pattern || *str != '\0' && *pattern == '.')
            return match(str + 1, pattern + 1);
        else
            return false;
    }
    else
    {
        if (*str == *pattern || *str != '\0' && *pattern == '.')
            return match(str, pattern + 2) || match (str + 1， pattern);
        else
            return match(str, pattern + 2);
    }
}
```

## 面试题5：[表示数值的字符串](https://github.com/Duanyu950425/-offer/blob/master/02.%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81/02.%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81_%E4%BB%A3%E7%A0%81/05.%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2.cpp)

**题目**：请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串"+100"，"5e2"，"-123"，"3.1416"和"-1E-16"都表示数值。 但是"12e"， "1a3.14"， "1.2.3"，"+-5"和"12e+4.3"都不是。

**解题思路**：

1.  小数点只能出现一次，且E或e也只能出现一次；
2.  正负号只能出现在一开始或紧跟着e或E；
3.  e或E不能是最后一个；
4.  符号错乱的，不在0~9之间的是错误的。

```c++
bool isNumeric(char* str)
{
    //标记符号、小数点、e是否出现过
    bool sign = false, decimal = false, hasE = false;
    for (int i = 0; i < strlen(str); i++)
    {
        if (str[i] == 'e' || str[i] == 'E')
        {
            if (i == strlen(str) - 1)//e后面一定要有数字，所以e不能再最后
                return false;
            if (hasE)//不能有两个e同事存在
                return false;
            hasE = true;
        }
        else if (str[i] == '+' || str[i] == '-')
        {
            //第二次出现+-符号，且不是在字符串开头，则也必须紧挨在e后面
            if (sign && str[i - 1] != 'e' && str[i - 1] != 'E')
                return false;
            //第一次出现+-符号，且不是在字符串开头，则也必须紧挨在e之后
            if (!sign && i > 0 && str[i - 1] != 'e' && str[i - 1] != 'E')
                return false;
            sign = true;
        }
        else if (str[i] == '.')
        {
            //e后面不能接小数点，小数点不能出现两次
            if (hasE || decimal)
                return false;
            decimal = true;
        }
        else if (str[i] < '0' || str[i] > '9')
            return false;
    }
    return true;
}
```

## 面试题6：[调整数组顺序使奇数位于偶数前面](https://github.com/Duanyu950425/-offer/blob/master/02.%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81/02.%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81_%E4%BB%A3%E7%A0%81/06.%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2.cpp)

**题目**：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。

**解题思路**：可以开辟一个新的数组空间来存放数组。要统计奇数的个数，方便存放。

```c++
void reOrderArray(vector<int> &array) 
{
    int size = array.size();
    if (size == 0)
        return ;
    int *aux = new int[size];
    int oddCount = 0;
    for (int i = 0; i < size; i++)
    {
        aux[i] = array[i];
        if (aux[i] % 2 != 0)
            oddCount++;
    }
    int i = 0;
    int left = 0;
    int mid = oddCount;
    while (left <= mid && i < size)
    {
        if (aux[i] % 2 == 0)
        {
            array[mid] = aux[i];
            mid++;
            i++
        }
        else
        {
            array[left] = aux[i];
            left++;
            i++;
        }
    }
}
```

## 面试题7：[链表中倒数第k个节点](https://github.com/Duanyu950425/-offer/blob/master/02.%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81/02.%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81_%E4%BB%A3%E7%A0%81/07.%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9.cpp)

**题目**：输入一个链表，输出该链表中倒数第k个结点。

**解题思路**：假设一共有n个节点，要找倒数第k个节点，也就是正数第n-k+1个节点。我们可以指定两个指针，一个走的快一个走的慢，走得快的先走k-1个节点，然后两个指针开始以相同的速度前进，当走得快的指针走到链表的尾部时，走的慢的指针刚好到达第n-k+1个节点，即倒数第k个节点。

```c++
ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) 
{
    if (pListHead == NULL || k <= 0)
        return NULL;
    ListNode *pFast = pListHead;
    for (unsigned int i = 0; i < k - 1; i++)
    {
        if (pFast->next != NULL)
            pFast = pFast->next;
        else
            return NULL;
    }
    ListNode *pSlow = pListHead;
    while (pFast->next != NULL)
    {
        pFast = pFast->next;
        pSlow = pSlow->next;
    }
    return pSlow;
}
```

## 面试题8：[链表中环的入口地址](https://github.com/Duanyu950425/-offer/blob/master/02.%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81/02.%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81_%E4%BB%A3%E7%A0%81/08.%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E5%9C%B0%E5%9D%80.cpp)

**题目**：给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。

**解题思路**：

1. 首先我们要知道的是这个链表中是否存在环。如何确定链表中是否存在环，我们可以设置两个指针，一个指针走的快，一次走两步，一个指针走的慢，一次只走一步。如果快的指针走到最后等于NULL都没有追上走的慢的指针，说明不存在环；如果追上了，说明存在环。
2. 确定环的入口地址在哪里。我们依旧可以用两个指针来确定。如果环内有n个节点，那么一个指针现在链表上移动n步，随后两个指针以相同的速度前进，相遇的地方就是环的入口地址。
3. 如何确定环内节点个数。由1，两个指针相遇的节点一定是在环中，可以从这个节点出发，一边继续向前移动一边计数，当再次返回这个节点，就可以得到环中的节点个数了。

```c++
ListNode *MeetingNode(ListNode *pHead)
{
    if (pHead == NULL)
        return NULL;
    ListNode *pSlow = pHead->next;
    if (pSlow == NULL)
        return NULL;
    ListNode *pFast = pSlow->next;
    while (pFast != NULL && pSlow != NULL)
    {
        if (pFast == pSlow)
            return pFast;
        pSlow = pSlow->next;
        pFast = pFast->next;
        if (pFast != NULL)
            pFast = pFast->next;
    }
    return NULL;
}
ListNode *EntryNodeOfLoop(ListNode *pHead)
{
    ListNode *meetingNode = MeetingNode(pHead);
    if (meetingNode == NULL)
        return NULL;
    ListNode *pNode1 = meetingNode;
    int nodeInLoop = 1;
    while(pNode->next != meetingNode)
    {
        pNode1 = pNode1->next;
        ++nodeInLoop;
    }
    pNode1 = pHead;
    for (int i = 0; i < nodeInLoop; i++)
        pNode1 = pNode1->next;
    ListNode *pNode2 = pHead;
    while (pNode1 != pNode2)
    {
        pNode1 = pNode1->next;
        pNode2 = pNode2->next;
    }
    return pNode1;
}
```

## 面试题9：[反转链表](https://github.com/Duanyu950425/-offer/blob/master/02.%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81/02.%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81_%E4%BB%A3%E7%A0%81/09.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.cpp)

**题目**：输入一个链表，反转链表后，输出新链表的表头。

**解题思路**：![avatar](https://github.com/Duanyu950425/-offer/blob/master/%E5%9B%BE%E7%89%87/02_1.png)

​	如上图所示，由于e节点的next指向了它的前一个节点，导致无法遍历到节点f。为了避免链表在节点i处断开，我们需要调整节点i的next之前，把节点f保存下来。

​	也就是说，我们在调整节点i的next指针时，除了需要知道节点e本身，还需要知道i的前一个节点h，因为我们需要把节点e的next指针指向d。同时我们还需要事先保存e的下一个节点f，以防止链表断开。

​	所以我们需要定义3个指针，1. 指向当前遍历到的节点； 2. 它的前一个节点； 3. 它的后一个节点。

```c++
ListNode* ReverseList(ListNode* pHead) 
{
    if (pHead == NULL)
        return NULL;
    ListNode *pReverseNode = NULL;
    ListNode *pCurrent = pHead;
    ListNode *pPre = NULL;
    while (pCurrent != NULL)
    {
        ListNode *pNext = pCurrent->next;
        if (pNext == NULL)
            pReverseNode = pCurrent;
        pCuurent->next = pPre;
        pPre = pCurrent;
        pCurrent = pNext;
    }
    return pReverseNode;
}
```

## 面试题10：[合并两个排序的链表](https://github.com/Duanyu950425/-offer/blob/master/02.%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81/02.%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81_%E4%BB%A3%E7%A0%81/10.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8.cpp)

**题目**：输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。

**解题思路**：![avatar](https://github.com/Duanyu950425/-offer/blob/master/%E5%9B%BE%E7%89%87/02_2.png)

​	在这道题目中，需要创建一个新的节点来将两个链表回合成一个链表。

```c++
ListNode* Merge(ListNode* pHead1, ListNode* pHead2)
{
    if (pHead1 == NULL)
        return pHead2;
    else if (pHead2 == NULL)
        return pHead1;
    ListNode *pMergeNode = NULL;
    if (pHead1->val < pHead2->val)
    {
        pMergeNode = pHead1;
        pMergeNode->next = Merge(pHead1->next, pHead2);
    }
    else
    {
        pMergeNode = pHead2;
        pMergeNode->next = Merge(pHead1, pHead2->next);
    }
    return pMergeNode
}
```

## 面试题11：[树的子结构](https://github.com/Duanyu950425/-offer/blob/master/02.%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81/02.%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81_%E4%BB%A3%E7%A0%81/11.%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84.cpp)

**题目**：输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）

**解题思路**：什么是树的子结构？即B树与A树中的一部分完全相同，例如如下的两棵树：

![avatar](https://github.com/Duanyu950425/-offer/blob/master/%E5%9B%BE%E7%89%87/02_3.png)

​	如上图，B树与A树的根结点相同，则去比较B树与A树的左右子节点，发现B树与A树的左子节点不同，则不进行比较，将A树移向根结点的左子节点，发现B树的根结点与A树的根结点的左子节点相同，则比较其子节点。

​	如果左子节点比较完后都与B树不相同，则比较右子节点。若全部比较完后，都不相同，则说明B树不是A树的子结构。

```c++
bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2)
{
    bool result = false;
    while (pRoot1 != NULL && pRoot2 != NULL)
    {
        if (pRoot1->val == pRoot2->val)
            result = DoesTree1HasTree2(pRoot1, pRoot2);
        if (!result)
            result = DoesTree1HasTree2(pRoot1->left, pRoot2);
        if (!result)
            result = DoesTree1HasTree2(pRoo1->right, pRoot2);
    }
}
bool DoesTree1HasTree2(TreeNode* pRoot1, TreeNode* pRoot2)
{
    if (pRoot2 == NULL)
        return true;
    if (pRoot1 == NULL)
        return false;
    if (pRoot1->val != pRoot2->val)
        return false;
    return DoesTree1HasTree2(pRoot1->left, pRoot2->left) && DoesTree1HasTree2(pRoot1->right, pRoot2->right);
}
```

