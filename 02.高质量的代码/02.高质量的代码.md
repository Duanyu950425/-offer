# 目录

### [面试题1：数值的整数次方]()

### [面试题2：打印从1到最大的n位数]()

### [面试题3：删除链表的节点]()

### [面试题4：正则表达式匹配]()

### [面试题5：表示数值的字符串]()

### [面试题6：调整数组顺序使奇数位于偶数前面]()

### [面试题7：链表中倒数第k个节点]()

### [面试题8：链表中环的入口地址]()

### [面试题9：反转链表]()











# 高质量的代码

## 面试题1：数值的整数次方

**题目**：实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。

**解题思路**：考虑问题要全面。1. 底数为0，指数为负？2. 指数为负？3. 正数情况

```c++
double Power(double base, int exponent)
{
    if (equal(base, 0.0) && exponent < 0)
        return 0.0;
    unsigned int absExponent = (unsigned int)(exponent);
    if (exponent < 0)
        absExponent = (unsigned int)(-exponent);
    double result = PowerWithUnsignedExponent(base, absExponent);
    if (exponent < 0)
        result = 1.0 / result;
    return result;
}
double PowerWithUnsignedExponent(double base, int exponent)
{
    double result = 1.0;
    for (int i = 1; i <= exponent; ++i)
        result *= base;
    return result;
}
bool equal(double base, double val)
{
    double diff = base - val;
    if (diff >= -0.0000001 && diff < 0.0000001)
        return true;
    return false;
}
```

## 面试题2：打印从1到最大的n位数

**题目**：输入数字n， 按顺序打印出从1到最大的n位十进制数。比如输入3，则打印出1、2、3一直到最大的3位数999。

**解题思路**：这道题很有可能会陷入大数溢出的困扰。为了解决这一困扰，我们采用字符串或者数组来表示大数。因为数字最大是n位，因此我们需要一个长度为n+1的字符串（最后有结束符'\0'）。首先把字符串中的每一个数字都初始化为'0'，然后每一次为字符串表示的数字加1，再打印出来。

## 面试题3：删除链表的节点

**题目一**：在O(1)的时间内删除链表节点

​	给定单向链表的头结点和一个节点指针，定义一个函数在O(1)时间内删除该节点。

**解题思路**：删除的节点可能是三种情况：1. 链表中有多个节点，删除的是尾节点；2. 链表中只有一个节点，删除的即使头结点也是尾节点；3. 链表中有多个节点，删除的不是尾节点。

```c++
struct ListNode
{
	int m_nValue;
	ListNode *m_pNext;
};
void DeleteNode(ListNode **pListHead, ListNode *pToBeDeleted)
{
    if (pListHead == NULL || pToBeDeleted == NULL)
        return ;
    if (pToBeDeleted->m_pNext != NULL)
    {
        ListNode *pNext = pToBeDeleted->m_pNext;
        pToBeDeleted->m_nValue = pNext->m_nValue;
        pToBeDeleted->m_pNext = pNext->m_pNext;
        
        delete pToBeDeleted;
        pToBeDeleted = NULL;
    }
    else if (*pListHead == pToBeDeleted)
    {
        delete pToBeDeleted;
        pToBeDeleted = NULL;
        *pListHead = NULL;
    }
    else
    {
        ListNode *pNode = pListHead;
        while (pNode->m_pNext != pToBeDeleted)
           pNode = pNode->m_pNext;
        pNode->m_pNext = NULL;
        delete pToBeDeleted;
        pToBeDeleted = NULL;
    }
}
```

## 面试题4：正则表达式匹配

**题目**：请实现一个函数用来匹配包括'.'和'\*'的正则表达式。模式中的字符'.'表示任意一个字符，而'\*'表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab\*ac\*a"匹配，但是与"aa.a"和"ab\*a"均不匹配

**解题思路**：解这题需要把题意仔细研究清楚。
    

​	首先，考虑特殊情况：
​         

1. 两个字符串都为**空**，返回true。

2. 当**第一个字符串不空**，而**第二个字符串空了**，返回false（因为这样，就无法匹配成功了，而如果第一个字符串空了，第二个字符串非空，还是可能匹配成功的，比如第二个字符串是“a\*a\*a\*a\*”，由于‘\*’之前的元素可以出现0次，所以有可能匹配成功）
       

3. 之后就开始匹配第一个字符，这里有两种可能：匹配成功或匹配失败。但考虑到pattern下一个字符可能是‘\*’， 这里我们分两种情况讨论：pattern下一个字符为‘\*’或不为‘\*’：
             

   ​			1> **pattern下一个字符不为‘\*’**：这种情况比较简单，直接匹配当前字符。如果匹配成功，继续匹配下一个；如果匹配失败，直接返回false。注意这里的 “匹配成功”，除了两个字符相同的情况外，还有一种情况，就是pattern的当前字符为‘.’，同时str的当前字符不为‘\0’。
   ​          

   ​			2> **pattern下一个字符为‘\*’**时，稍微复杂一些，因为‘\*’可以代表0个或多个。

- 这里把这些情况都考虑到：

​					a> **当‘\*’匹配0个字符时**，str当前字符不变，pattern当前字符后移两位，跳过这个‘\*’符号；
​               

​					b> **当‘\*’匹配1个或多个时**，str当前字符移向下一个，pattern当前字符不变。（这里匹配1个或多个可以看成一种情况，因为：当匹配一个时，由于str移到了下一个字符，而pattern字符不变，就回到了上边的情况a；当匹配多于一个字符时，相当于从str的下一个字符继续开始匹配）之后再写代码就很简单了。

```c++
bool match(char* str, char* pattern)
{
    if (*str == '\0' && *pattern == '\0')
        return true;
    if (*str != '\0' && *pattern == '\0')
        return false;
    if (*(pattern + 1) != '*')
    {
        if (*str == *pattern || *str != '\0' && *pattern == '.')
            return match(str + 1, pattern + 1);
        else
            return false;
    }
    else
    {
        if (*str == *pattern || *str != '\0' && *pattern == '.')
            return match(str, pattern + 2) || match (str + 1， pattern);
        else
            return match(str, pattern + 2);
    }
}
```

## 面试题5：表示数值的字符串

**题目**：请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串"+100"，"5e2"，"-123"，"3.1416"和"-1E-16"都表示数值。 但是"12e"， "1a3.14"， "1.2.3"，"+-5"和"12e+4.3"都不是。

**解题思路**：

1.  小数点只能出现一次，且E或e也只能出现一次；
2.  正负号只能出现在一开始或紧跟着e或E；
3.  e或E不能是最后一个；
4.  符号错乱的，不在0~9之间的是错误的。

```c++
bool isNumeric(char* str)
{
    //标记符号、小数点、e是否出现过
    bool sign = false, decimal = false, hasE = false;
    for (int i = 0; i < strlen(str); i++)
    {
        if (str[i] == 'e' || str[i] == 'E')
        {
            if (i == strlen(str) - 1)//e后面一定要有数字，所以e不能再最后
                return false;
            if (hasE)//不能有两个e同事存在
                return false;
            hasE = true;
        }
        else if (str[i] == '+' || str[i] == '-')
        {
            //第二次出现+-符号，且不是在字符串开头，则也必须紧挨在e后面
            if (sign && str[i - 1] != 'e' && str[i - 1] != 'E')
                return false;
            //第一次出现+-符号，且不是在字符串开头，则也必须紧挨在e之后
            if (!sign && i > 0 && str[i - 1] != 'e' && str[i - 1] != 'E')
                return false;
            sign = true;
        }
        else if (str[i] == '.')
        {
            //e后面不能接小数点，小数点不能出现两次
            if (hasE || decimal)
                return false;
            decimal = true;
        }
        else if (str[i] < '0' || str[i] > '9')
            return false;
    }
    return true;
}
```

## 面试题6：调整数组顺序使奇数位于偶数前面

**题目**：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。

**解题思路**：可以开辟一个新的数组空间来存放数组。要统计奇数的个数，方便存放。

```c++
void reOrderArray(vector<int> &array) 
{
    int size = array.size();
    if (size == 0)
        return ;
    int *aux = new int[size];
    int oddCount = 0;
    for (int i = 0; i < size; i++)
    {
        aux[i] = array[i];
        if (aux[i] % 2 != 0)
            oddCount++;
    }
    int i = 0;
    int left = 0;
    int mid = oddCount;
    while (left <= mid && i < size)
    {
        if (aux[i] % 2 == 0)
        {
            array[mid] = aux[i];
            mid++;
            i++
        }
        else
        {
            array[left] = aux[i];
            left++;
            i++;
        }
    }
}
```

## 面试题7：链表中倒数第k个节点

**题目**：输入一个链表，输出该链表中倒数第k个结点。

**解题思路**：假设一共有n个节点，要找倒数第k个节点，也就是正数第n-k+1个节点。我们可以指定两个指针，一个走的快一个走的慢，走得快的先走k-1个节点，然后两个指针开始以相同的速度前进，当走得快的指针走到链表的尾部时，走的慢的指针刚好到达第n-k+1个节点，即倒数第k个节点。

```c++
ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) 
{
    if (pListHead == NULL || k <= 0)
        return NULL;
    ListNode *pFast = pListHead;
    for (unsigned int i = 0; i < k - 1; i++)
    {
        if (pFast->next != NULL)
            pFast = pFast->next;
        else
            return NULL;
    }
    ListNode *pSlow = pListHead;
    while (pFast->next != NULL)
    {
        pFast = pFast->next;
        pSlow = pSlow->next;
    }
    return pSlow;
}
```

## 面试题8：链表中环的入口地址

**题目**：给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。

**解题思路**：

1. 首先我们要知道的是这个链表中是否存在环。如何确定链表中是否存在环，我们可以设置两个指针，一个指针走的快，一次走两步，一个指针走的慢，一次只走一步。如果快的指针走到最后等于NULL都没有追上走的慢的指针，说明不存在环；如果追上了，说明存在环。
2. 确定环的入口地址在哪里。我们依旧可以用两个指针来确定。如果环内有n个节点，那么一个指针现在链表上移动n步，随后两个指针以相同的速度前进，相遇的地方就是环的入口地址。
3. 如何确定环内节点个数。由1，两个指针相遇的节点一定是在环中，可以从这个节点出发，一边继续向前移动一边计数，当再次返回这个节点，就可以得到环中的节点个数了。

```c++
ListNode *MeetingNode(ListNode *pHead)
{
    if (pHead == NULL)
        return NULL;
    ListNode *pSlow = pHead->next;
    if (pSlow == NULL)
        return NULL;
    ListNode *pFast = pSlow->next;
    while (pFast != NULL && pSlow != NULL)
    {
        if (pFast == pSlow)
            return pFast;
        pSlow = pSlow->next;
        pFast = pFast->next;
        if (pFast != NULL)
            pFast = pFast->next;
    }
    return NULL;
}
ListNode *EntryNodeOfLoop(ListNode *pHead)
{
    ListNode *meetingNode = MeetingNode(pHead);
    if (meetingNode == NULL)
        return NULL;
    ListNode *pNode1 = meetingNode;
    int nodeInLoop = 1;
    while(pNode->next != meetingNode)
    {
        pNode1 = pNode1->next;
        ++nodeInLoop;
    }
    pNode1 = pHead;
    for (int i = 0; i < nodeInLoop; i++)
        pNode1 = pNode1->next;
    ListNode *pNode2 = pHead;
    while (pNode1 != pNode2)
    {
        pNode1 = pNode1->next;
        pNode2 = pNode2->next;
    }
    return pNode1;
}
```

## 面试题9：反转链表

**题目**：输入一个链表，反转链表后，输出新链表的表头。

**解题思路**：![avatar](https://github.com/Duanyu950425/-offer/blob/master/%E5%9B%BE%E7%89%87/02_1.png)

​	如上图所示，由于e节点的next指向了它的前一个节点，导致无法遍历到节点f。为了避免链表在节点i处断开，我们需要调整节点i的next之前，把节点f保存下来。

​	也就是说，我们在调整节点i的next指针时，除了需要知道节点e本身，还需要知道i的前一个节点h，因为我们需要把节点e的next指针指向d。同时我们还需要事先保存e的下一个节点f，以防止链表断开。

​	所以我们需要定义3个指针，1. 指向当前遍历到的节点； 2. 它的前一个节点； 3. 它的后一个节点。

```c++
ListNode* ReverseList(ListNode* pHead) 
{
    if (pHead == NULL)
        return NULL;
    ListNode *pReverseNode = NULL;
    ListNode *pCurrent = pHead;
    ListNode *pPre = NULL;
    while (pCurrent != NULL)
    {
        ListNode *pNext = pCurrent->next;
        if (pNext == NULL)
            pReverseNode = pCurrent;
        pCuurent->next = pPre;
        pPre = pCurrent;
        pCurrent = pNext;
    }
    return pReverseNode;
}
```

