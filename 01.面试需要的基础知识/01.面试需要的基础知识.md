# 目录

## [面试题1：数组中重复的数字](https://github.com/Duanyu950425/-offer/blob/master/01.%E9%9D%A2%E8%AF%95%E9%9C%80%E8%A6%81%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01.%E9%9D%A2%E8%AF%95%E9%9C%80%E8%A6%81%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md#%E9%9D%A2%E8%AF%95%E9%A2%981%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97)

## [面试题2：二维数组中的查找](https://github.com/Duanyu950425/-offer/blob/master/01.%E9%9D%A2%E8%AF%95%E9%9C%80%E8%A6%81%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01.%E9%9D%A2%E8%AF%95%E9%9C%80%E8%A6%81%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md#%E9%9D%A2%E8%AF%95%E9%A2%982%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE)

## [面试题3：替换空格](https://github.com/Duanyu950425/-offer/blob/master/01.%E9%9D%A2%E8%AF%95%E9%9C%80%E8%A6%81%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01.%E9%9D%A2%E8%AF%95%E9%9C%80%E8%A6%81%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md#%E9%9D%A2%E8%AF%95%E9%A2%983%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC)

## [面试题4：从尾到头打印链表](https://github.com/Duanyu950425/-offer/blob/master/01.%E9%9D%A2%E8%AF%95%E9%9C%80%E8%A6%81%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01.%E9%9D%A2%E8%AF%95%E9%9C%80%E8%A6%81%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md#%E9%9D%A2%E8%AF%95%E9%A2%984%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8)

## [面试题5：重建二叉树](https://github.com/Duanyu950425/-offer/blob/master/01.%E9%9D%A2%E8%AF%95%E9%9C%80%E8%A6%81%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01.%E9%9D%A2%E8%AF%95%E9%9C%80%E8%A6%81%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md#%E9%9D%A2%E8%AF%95%E9%A2%985%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91)

## [面试题6：二叉树的下一个节点](https://github.com/Duanyu950425/-offer/blob/master/01.%E9%9D%A2%E8%AF%95%E9%9C%80%E8%A6%81%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01.%E9%9D%A2%E8%AF%95%E9%9C%80%E8%A6%81%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md#%E9%9D%A2%E8%AF%95%E9%A2%986%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9)

## [面试题7：用两个栈实现队列](https://github.com/Duanyu950425/-offer/blob/master/01.%E9%9D%A2%E8%AF%95%E9%9C%80%E8%A6%81%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01.%E9%9D%A2%E8%AF%95%E9%9C%80%E8%A6%81%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md#%E9%9D%A2%E8%AF%95%E9%A2%987%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97)

## [面试题8：斐波那契数列](https://github.com/Duanyu950425/-offer/blob/master/01.%E9%9D%A2%E8%AF%95%E9%9C%80%E8%A6%81%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01.%E9%9D%A2%E8%AF%95%E9%9C%80%E8%A6%81%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md#%E9%9D%A2%E8%AF%95%E9%A2%988%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97)

## [面试题9：旋转数组中最小的数](https://github.com/Duanyu950425/-offer/blob/master/01.%E9%9D%A2%E8%AF%95%E9%9C%80%E8%A6%81%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01.%E9%9D%A2%E8%AF%95%E9%9C%80%E8%A6%81%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md#%E9%9D%A2%E8%AF%95%E9%A2%989%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0)

## [面试题10：矩阵中的路径](https://github.com/Duanyu950425/-offer/blob/master/01.%E9%9D%A2%E8%AF%95%E9%9C%80%E8%A6%81%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01.%E9%9D%A2%E8%AF%95%E9%9C%80%E8%A6%81%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md#%E9%9D%A2%E8%AF%95%E9%A2%9810%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84)

## [面试题11：机器人的运动范围](https://github.com/Duanyu950425/-offer/blob/master/01.%E9%9D%A2%E8%AF%95%E9%9C%80%E8%A6%81%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01.%E9%9D%A2%E8%AF%95%E9%9C%80%E8%A6%81%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md#%E9%9D%A2%E8%AF%95%E9%A2%9811%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4)

## [面试题12：剪绳子](https://github.com/Duanyu950425/-offer/blob/master/01.%E9%9D%A2%E8%AF%95%E9%9C%80%E8%A6%81%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01.%E9%9D%A2%E8%AF%95%E9%9C%80%E8%A6%81%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md#%E9%9D%A2%E8%AF%95%E9%A2%9812%E5%89%AA%E7%BB%B3%E5%AD%90)

## [面试题13：二进制中1的个数](https://github.com/Duanyu950425/-offer/blob/master/01.%E9%9D%A2%E8%AF%95%E9%9C%80%E8%A6%81%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01.%E9%9D%A2%E8%AF%95%E9%9C%80%E8%A6%81%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md#%E9%9D%A2%E8%AF%95%E9%A2%9813%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0)















# 面试需要的基础知识



## 面试题1：数组中重复的数字

### 题目一：找出数组中重复的数字

​	在一个长度为n的数组里的所有数字都在0~n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中人一个重复的数字。例如，如果输入长度为7的数组{ 2,3,1,0,2,5,3 }，那么对应的输出是重复的数字2或者3。

**解题思路**：我们可以通过排序取出数组中重复的数字。因为数组中所有的数字都在0~n-1之间，所以我们可以将数字为0的数放置在数组下标为0的位置，将数字1放置在数组下标为1的位置……。一旦发现某一位置上的值与将要放置的值相同，则将其输出。

```c++
void BySortingNum(int number[], int length)
{
	if (number == NULL || length <= 0)
		return;
	for (int i = 0; i < length - 1; i++)
	{
		if (number[i] < 0 || number[i] > length - 1)
        return;
	}
	for (int i = 0; i < length; ++i)
	{
		while (number[i] != i)
		{
			if (number[i] == number[number[i]])
			{
				cout << number[i] << endl;
				return;
			}
			int temp = number[i];
			number[i] = number[temp];
			number[temp] = temp;
		}
	}
}
int main()
{
	int a[] = { 2,3,1,0,2,5,3 };
	int n = 7;
	solution s;
	s.BySortingNum(a, n);
	return 0;
}
```

​	*完整代码可以参考代码目录。*

### 题目二：不修改数组找出重复的数字

​	在一个长度为n+1的数组里的所有数字都在1~n的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，如果输入长度为8的数组{ 2,3,5,4,3,2,6,7 }，那么对应的输出是重复的数字2或3。

**解题思路**：为了节省空间，我们不使用心得内存空间。由于数字大小在一定范围内，则我们可以将数字二分，即吧1~n的数字从中间的数字m分成两部分。如果1~m的数字的数目超过m，则这一半的区间里一定包含重复的数字；否则，m+1~n这一半一定包含重复的数字。我们可以继续将这一半的数字二分，直到找到一个重复的数字。

```c++
//不修改数组找到重复的数字
int ByBinarySearch(int number[], int length)
{
	if (number == NULL || length <= 0)
		return 0;
	int start = 1;
	int end = length - 1;
	while (end >= start)
	{
		int middle = ((end - start) >> 1) + start;
		int count = countRange(number, length, start, middle);
		if (end == start)
		{
			if (count > 1)
				return start;
			else
				break;
		}
		if (count > middle - start + 1)
			end = middle;
		else
			start = middle + 1;
	}
	return -1;
}
int countRange(int number[], int length, int start, int end)//数一下在start到end范围内一共有多少个数字
{
	if (number == NULL)
		return 0;
	int count = 0;
	for (int i = 0; i < length; i++)
		if (number[i] >= start && number[i] <= end)
			++count;
	return count;
}
```

## 面试题2：二维数组中的查找

**题目**：在一个二维数组中，每一行都按照从左到右递增的书序排序，每一列都按照从上到下的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

**解题思路**：假设我们输入一个数字，我们可以先从二维数组的任何一个角开始寻找，但是最好是从右上开始寻找。因为这个位置恰好是一行数的最大一个，一列数的最小一个。因此我们从这个位置开始寻找。如若此值小于右上这一值，则其一定不在此列。按照此思路一次寻找。

```c++
bool Find(int target, vector<vector<int> > array)
{
	int rows = array.size();
	int cols = array[0].size();
	int i = 0, j = cols - 1;
	while (i < rows && j >= 0)
	{
		if (target < array[i][j])
			j--;
		else if (target > array[i][j])
			i++;
		else
			return true;
	}
	return false;
}
```

## 面试题3：替换空格？？

**题目**：请实现一个函数，把字符串中的每一个空格替换成"%20"。例如，输入“We are happy”， 则输出“We%20are%20happy”。

**解题思路**：从前往后对数组进行赋值显然是不行的，会覆盖掉前面的数。所以我们需要从后往前赋值。又已知替换后的数组与替换前的关系，所以我们可以利用此关系进行赋值。

```c++
void replaceSpace(char *str, int length)
{
	if (str == NULL || length <= 0)
		return;
	int OldLength = 0;
	int OldSpaceLength = 0;
	int i = 0;
	while(str[i] != '\0')
	{
		OldLength++;
		if (str[i] == ' ')
			OldSpaceLength++;
		i++;
	}
	int NewLength = OldLength + OldSpaceLength * 2;
	while (OldLength >= 0 && NewLength > OldLength)
	{
		if (str[OldLength] == ' ')
		{
			str[NewLength--] = '0';
			str[NewLength--] = '2';
			str[NewLength--] = '%';
		}
		else
			str[NewLength--] = str[OldLength];
		OldLength--;
	}
}
```

## 面试题4：从尾到头打印链表

**题目**：输入一个链表的头结点，从尾到头反过来打印出每一个节点的值。

**解题思路**：由于是从尾到头打印链表，我们自然而然就想到了使用栈——先进后出。

```c++
vector<int> printListFromTailToHead(ListNode* head)
{
	vector<int> v;
	if (head == NULL)
		return v;
	ListNode *p = head;
	stack<int> s;
	while (p != NULL)
	{
		s.push(p->val);
		p = p->next;
	}
	while (!s.empty())
	{
		v.push_back(s.top());
		s.pop();
	}
	return v;
}
```

## 面试题5：重建二叉树

**题目**：输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如：输入前序遍历的序列{ 1,2,4,7,3,5,6,8 }和中序遍历序列{ 4,7,2,1,5,3,8,6 }，则重建二叉树如下图所示并输出它的头结点。![avatar](https://github.com/Duanyu950425/-offer/blob/master/%E5%9B%BE%E7%89%87/01_1.png)

**解题思路**：前序遍历的第一个节点即为整棵树的根结点。而在中序遍历中，根结点位于整个序列的中部，且根结点左边为树的左子树，右边为树的右子树。依次递归重建二叉树。

```c++
TreeNode* reConstructBinaryTree(vector<int> pre, vector<int> vin) 
{
	int length = vin.size();
	if (length == 0)
		return NULL;
	TreeNode *head = new TreeNode(pre[0]);//建立一个头结点，用来重建二叉树
	vector<int> left_in, left_pre, right_in, right_pre;//建立四个容器，来存放递归后的结果
	int gen = 0;//这是中序遍历中根结点所在的位置
	for (int i = 0; i < length; i++)
	{
		if (vin[i] == pre[0])
		{
			gen = i;//找到根结点所在位置，则停止
			break;
		}
	}
	for (int i = 0; i < gen; i++)
	{
		left_pre.push_back(pre[i + 1]);
		left_in.push_back(vin[i]);
	}
	for (int i = gen + 1; i < length; i++)
	{
		right_pre.push_back(pre[i]);
		right_in.push_back(vin[i]);
	}
	head->left = reConstructBinaryTree(left_pre, left_in);
	head->right = reConstructBinaryTree(right_pre, right_in);
	return head;
}
```

## 面试题6：二叉树的下一个节点

**题目**：给定一棵二叉树和其中一个节点，如何找出中序遍历序列的下一个节点？树中的节点除了有连个分别指向左、右子节点的指针，还有一个指向父节点的指针。

![avatar](https://github.com/Duanyu950425/-offer/blob/master/%E5%9B%BE%E7%89%87/01_2.png)

**解题思路**：如上图所示。

1. 如果一个节点有右子树，那么它的下一个节点就是它右子树的最左子节点。例如节点b的下一个节点就是节点h，节点a的下一个节点就是节点f。
2. 如果一个节点没有右子树，且此节点是父节点的左子树，那么它的下一个节点就是父节点。例如节点d的下一个节点就是节点b，节点f的下一个节点就是节点c。
3. 如果一个节点既没有右子树，还是它父节点的右节点。我们需要沿着指向父节点的指针一直向上遍历，直到找到一个是它父节点的左子节点的节点。如果这样的节点存在，那么这个节点的父节点就是我们要找的下一个节点。如节点i的下一个节点，沿着父节点的指针到达节点e。由于节点e又是它父节点的右子节点，继续向上遍历，到达节点b，节点b是它父节点的左子节点，则节点i的下一个节点就是节点b的父节点a。

```c++
#include<iostream>
#include<vector>
#include<stack>
using namespace std;

struct BinaryTreeNode {
	int val;
	BinaryTreeNode *m_pLeft;
	BinaryTreeNode *m_pRight;
	BinaryTreeNode *m_pParent;
};
BinaryTreeNode *GetNext(BinaryTreeNode *pNode)
{
    if (pNode == NULL)
        return NULL;
    BinaryTreeNode *pNext = NULL;
    if (pNode->m_pRight != NULL)//如果此节点的右子节点不为NULL，则此节点的下一个节点就是右子节点的左子节点。
    {
        BinaryTreeNode *pRight = pNode->m_pRight;
        while (pRight->m_pLeft != NULL)
            pRight = pRight->m_pLeft;
        pNext = pRight;
    }
    else if (pNode->m_pParent != NULL)
    {
        BinaryTreeNode *pCurrent = pNode;
        BinaryTreeNode *pParent = pNode->m_pParent;
        while (pParent != NULL && pCurrent == pParent->m_pRight)//如果此节点为父节点的右子节点，且其没有右子树
        {
            pCurrent = pParent;
            pParent = pParent->m_pParent;
        }
        pNext = pParent;
    }
    return pNext;
}
```

## 面试题7：用两个栈实现队列

**题目**：用两个栈实现一个队列，队列的声明如下，请实现它的两个函数appendTail和deleteHead，分别完成在队列尾部插入节点和在队列头部删除节点的功能。

**解题思路**：队列是先进先出的，而栈是先进后出的。所以使用两个栈实现一个队列，则一个栈是入队操作，另一个栈出队操作。当要出栈时，要将入队的数全部转移至出队的栈中依次出栈。如果出队的栈不为空，则先要将出队的栈清空再入栈。

```c++
void push(int node) 
{
	stack1.push(node);
}

int pop() 
{
	int top;
	if (stack2.empty())
	{
		while (!stack1.empty())
		{
			stack2.push(stack1.top());
			stack1.pop();
		}
	}
	top = stack2.top();
	stack2.pop();
	return top;
}
```

## 面试题8：斐波那契数列

**题目**：求斐波那契数列的第n项。

**解题思路**：想要解出这道题，首先需要知道什么是斐波那契数列。满足以下关系的数列即为斐波那契数列。

![avatar](https://github.com/Duanyu950425/-offer/blob/master/%E5%9B%BE%E7%89%87/01_3.png)

```c++
int Fibonacci_Recur(int n)//递归
{
	if (n < 0)
		return -1;
	if (n == 0)
		return 0;
	if (n == 1)
		return 1;
	return Fibonacci_Recur(n - 2) + Fibonacci_Recur(n - 1);
}
int Fibonacci_Itera(int n)//迭代
{
	if (n < 0)
		return -1;
	if (n == 0)
		return 0;
	if (n == 1)
		return 1;
	int num0 = 0, num1 = 1;
	int sum;
	for (int i = 2; i <= n; i++)
	{
		sum = num0 + num1;
		num0 = num1;
		num1 = sum;
	}
	return sum;
}
```

​	通过斐波那契数列引申出许多的题目。

**题目**：青蛙跳台阶问题。一直青蛙一次可以跳上一级台阶，也可以跳上2级台阶。求该青蛙跳上一个n级台阶总共有多少种跳法。

**解题思路**：乍看这道题有些难解，但我们可以通过举例来说明。

| 总共台阶数 | 青蛙的总跳法                             |
| ---------- | ---------------------------------------- |
| 1          | （1）   1                                |
| 2          | （2，1 1）  2                            |
| 3          | （1 1 1，1 2，2 1）  3                   |
| 4          | （1 1 1 1，1 1 2，1 2 1，2 1 1，2 2）  5 |

这样总结下来，其实就是一个斐波那契数列。且n>0的数列。

**题目**：一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

**解题思路**：这道题我们依旧可以拆分来逐个分析

| 总共台阶数 | 青蛙的总跳法                                                 |
| ---------- | ------------------------------------------------------------ |
| 1          | （1）  1                                                     |
| 2          | （1 1，2）  2                                                |
| 3          | （1 1 1，1 2，2 1，3）  4                                    |
| 4          | （1 1 1 1，1 2 1，1 1 2，2 1 1，2 2，1 3，3 1，4）  8        |
| 5          | （1 1 1 1 1，1 1 1 2，1 1 2 1，1 2 1 1，2 1 1 1，1 2 2，2 1 2，2 2 1，1 3 1，1 1 3，3 1 1，1 4，4 1，5，2 3，3 2）  16 |

这样分析下来，我们可以知道若有n级台阶，则跳法为![avatar](https://github.com/Duanyu950425/-offer/blob/master/图片/01_4.png)。

```c++
int jumpFloorII(int number)
{
	if (number <= 0)
		return 0;
	if (number == 1)
		return 1;
	int val = 1;
	for (int i = 2; i <= number; i++)
	{
		val *= 2;
	}
	return val;
}
```

**题目**：我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2**n的大矩形，总共有多少种方法？

**解题思路**：我们可以试着画一下图来确定方法。

假设只有一个2*1的小矩形：![avatar](https://github.com/Duanyu950425/-offer/blob/master/%E5%9B%BE%E7%89%87/01_5.png)

假设有两个2*1的小矩形：![avatar](https://github.com/Duanyu950425/-offer/blob/master/%E5%9B%BE%E7%89%87/01_6.png)

假设有三个2*1的小矩形：![avatar](https://github.com/Duanyu950425/-offer/blob/master/%E5%9B%BE%E7%89%87/01_7.png)

假设有四个2*1的小矩形：![avatar](https://github.com/Duanyu950425/-offer/blob/master/%E5%9B%BE%E7%89%87/01_8.png)

这样一分析，即可知道此题也是斐波那契数列。

## 面试题9：旋转数组中最小的数

**题目**：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小的元素。例如，输入{ 3,4,5,1,2 }为{ 1,2,3,4,5 }的一个旋转，该数组的最小值为1.

**解题思路**：由于数组是递增的，则将数组旋转之后第一个后面的子序列要小于前面的子序列，则一开始减小的地方即为整个数字最小的数。例如题目中所给示例，3,4,5子序列递增，1,2,3子序列也是递增，但是1<5，所以1为整个数组最小的数。

​	但是要注意几个特别的地方。如果整个数列为{ 1,2,1,1,1 }的话，我们怎么知道旋转后的起点在哪里。

​	我们可以通过类似于二分法的办法。左子序列的第一个数要大于等于右子序列的最后一个数。

```c++
int minNumberInRotateArray(vector<int> rotateArray)
{
	int size = rotateArray.size();
	if (size == 0)
		return 0;
	int left = 0;
	int right = size - 1;
	int mid = 0;
	while (rotateArray[left] >= rotateArray[right])
	{
		if (right - left == 1)
		{
			mid = right;
			break;
		}
		mid = left + (right - left) / 2;
		if (rotateArray[left] == rotateArray[right] && rotateArray[left] == rotateArray[mid])//出现{ 1,2,1,1,1 }这种情况的解决办法
		{
			return MinOrder(rotateArray, left, right);
		}
		else if (rotateArray[mid] >= rotateArray[left])//二分法
			left = mid;
		else
			right = mid;
	}
	return rotateArray[mid];
}
int MinOrder(vector<int> rotateArray, int left, int right)
{
	int val = rotateArray[left];
	for (int i = left + 1; i <= right; i++)
	{
		if (rotateArray[i] < val)
			val = rotateArray[i];
	}
	return val;
}
```

## 面试题10：矩阵中的路径

## 面试题11：机器人的运动范围

## 面试题12：剪绳子

## 面试题13：二进制中1的个数

**题目**：请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。例如，把9表示成二进制是1001，有2位是1,。因此，如果输入9，则该函数输出2.

**解题思路**：通过与运算可以求出二进制中1的个数。最关键的是负数形式时，二进制中1的个数。负数在二进制中用补码表示。

```c++
int NumberOf1(int n)
{
    int count = 0;
    while (n)
    {
        ++count;
        n = (n - 1) & n;
    }
    return count;
}
```

